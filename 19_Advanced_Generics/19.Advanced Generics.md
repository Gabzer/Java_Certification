# Part 1

## Compile Erases Information about Generics

What generics do, they actually put a restriction on top of it. They say, OK, well, you don't have to say what it is, what that variable type parameter, return value type is right now when you create that class. But when you will use it, you will have to say what the type is. That's what generics are doing.
Now this process of removing the generics information from the compiled code is called erasure. We're erasing the information about the generics that we've coded.

## Generic and Raw Type Compatibility

```java 
public class Some implements UnaryOperator<String> {
    public String apply(String s) {
        return s;
    }
}
```

The actual generated code from this class, if you compile it and then you decompile it back to the source, this is what it will look like. Apparently, it will have that method that you just described. Yes, it will, of course. But it will also have a method, which is a complete equivalent of the method which is using generics, but which is using objects. And that other method will do the typecasting, basically.

```java 
public class Some implements UnaryOperator<String> {
    public String apply(String s) {
        return s;
    }
    /* bridge synthetic method generated by compiler */
    public Object apply(final Object o) {
        return this.apply((String)o);
    }
}
```



# Part 2

## Generics and Type Hierarchy

```java
Product[] products = new Food[10];
products[0] = new Drink("Tea");     //  java.lang.ArrayStoreException
```

Compiler, looking at this code, can't really say is this line of code correct or not. You will get an exception at runtime, but you won't get that code not compiled. From compiler point of view, yes, you can assign drink to a product array. The fact that actually it is referring to just foods is not obvious to the compiler.
This flaw is caused by the arrays being what we call **covariant**. Covariant basically means that an array of subtype is considered to be assignable to a variable declared as array of a super type. That's what covariant means.

What about **collection API**? Collections are designed to use generics. Unlike arrays, collections use generics. **And generics are invariant**.

```java
List<Product> products = new ArrayList<Food>();     //  Compiler error indicating incompatible types: ArrayList<Food> cannot be         
                                                    //  converted to List<Product>
```

The compiler says, a list of subtype is not the same as a list of supertype. So there you go. The compiler will basically, with lists, with collections API, will prevent you from running into the problem which you can run into when you're using arrays, because generics are invariant.

Generics compiler checks are not performed for **raw types**, wich can result in runtime exceptions:

```java
List<Food> foods = new ArrayList<Food>();
List values = foods;                //  raw type
List<Product> products = values;    //  compiler warns about unchecked or unsafe operations
products.add(new Drink("Tea"));     //  no compiler warning
Drink x1 = (Drink)values.get(0);
Food x2 = foods.get(0);             //  java.lang.ClassCastException: class blabla.Drink cannot be cast to class blabla.Food
```

## Wildcard Generics

Three possible scenarios:
1.**Generics are not applied**

```java
List listOfAnyObjects1 = new ArrayList();
List<Object> listOfAnyObjects2 = new ArrayList<>();
```

So that's essentially unrestricted scenario, when you didn't use generics. You use an object as generic is as good as not using generics at all.

2.When **Specific type is applied**:

```java
List<Product> listOfProducts = new ArrayList<>();
```

This collection behaves like an invariant collection. It's assumed that it can only store products or descendants of the product. So you can put their foods and drinks, but generally, this is anything that's compatible with the type that you declared. And you cannot store anything else but products, which is fine.

3.When **Wildcard <?> is applied**:

```java
List<?> listOfUnknownType = listOfProducts;     //  Such an assignment is covariant
```

Because you used a question mark here, it will be treated as unknown type-- well, seemingly. Question mark means you don't know what it is, right? But you see, the thing is, that in Java, there is no such thing as unknown type. Everything in Java must have a type. You can't just have a variable with no type.

So as a result, **this list will be read-only**. You will not be able to add anything to that list. It effectively turns collection into read-only mode. Because from the perspective of Java runtime, this will be like, what do you add to it? No value except-- OK, null can be added to that collection, fair enough. Because null is of no type.
We can specify upper and lower boundaries for the wildcard.

## Upper Bound Wildcard

Wildcard upper boundary looks like this: **<? extends type>**. And what it allows you to do, it actually turns your code into covariant code.
If you do this question mark extends product syntax, then you would be able to assign a list of drinks or a list of foods to such list, which is question mark products. A list of foods and list of drinks cannot be assigned to list of products, but list of food and list of drinks can be assigned to question mark extends product list. But it turns that object into read-only mode.

## Lower Bound Wildcard

**<? super type>**
Then what you'll be able to do is assigned to that list question mark super food a list of objects, a list of products, or a list to foods. What you won't be able to do is assign a list of drinks, because drink doesn't extend food, right? It's not a parent of food.
This is called a **contra-variant behavior**.
And the interesting thing is that this collection is _writable_.

## Collections and Generics Best Practices

So the normal behavior of a generic is **invariant** when you say, this is a list of specific type. And that's all there is to it.
If you want to create a situation when you want to write information to a collection in a type safe fashion, and then you can do the **contra-variant writable generics** <? super type>. Anything that's super class of food, anything that's super class of drink, will be acceptable in this situation.
If you want to be able to present a more specific type collection in a more generic way, like collection of foods presented as collection of products, for example, well, you could do that, but it will have to be turned **read-only**. So you have to use covariant behavior, which is <? extends type> a scenario.

And lastly, categorically avoid using raw types. You will start getting these unsafe operations. You'll potentially get heap pollution problems with raw types. So just avoid them altogether.